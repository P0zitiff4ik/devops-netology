[Задание](https://github.com/netology-code/sysadm-homeworks/blob/devsys10/03-sysadmin-02-terminal/README.md)

---
1. Какой системный вызов делает команда `cd`?
> chdir("/tmp")

---
2. Где находится база данных `file`, на основании которой она делает свои догадки
* `file` обращается к библиотеке, расположенной по адресу /lib/x86_64-linux-gnu/libmagic.so.1
* Также ищет файлы magic.mgc и magic в домашней папке и в /etc/, а также в /usr/share/misc/
* Если верить мануалу `man 5 magic`, база данных находится в файле /usr/share/misc/magic.mgc

---
3. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе)

Нашёл множество разных способов "обнулить" файл:
 * Через имя файла
   * `cat /dev/null > filename`
   * `echo -n > filename`
   * `> filename`
   * `truncate -s 0 filename`
 * Или через файловые дескрипторы:
   * Узнаём PID процесса, занявшего удалённый файл и используемый файловый дескриптор (`n`):
     * `sudo lsof | grep deleted`
       * `sudo truncate -s 0 /proc/PID/fd/n`
       * `echo '' >/proc/PID/fd/n`

Однако, ни с одним из них не получилось обнулить файл так, чтобы при перезаписи тем же процессом занятый объём при проверке командой `sudo lsof | grep deleted` не увеличивался. Для записи в файл использовал `vi`, а также `ping`.   

Таким образом, получается, "обнуление" работает только до следующей перезаписи файла занявшим его процессом. Если это не так, то прошу помочь с этой задачей.

----
4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

Нет, т.к. при становления зомби процесс освобождает все свои ресурсы. Однако в определённых условиях они могут доставить трудностей. Зомби не занимают памяти, но блокируют записи в таблице процессов, при переполнении которой все процессы пользователя не будут способны создавать новые дочерние процессы.
Источник - [wikipedia](https://ru.wikipedia.org/wiki/Процесс-зомби)

---
5. На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты?

```bash
root@vagrant:~# /usr/sbin/opensnoop-bpfcc -d 1
```
    PID    COMM               FD ERR PATH
    895    vminfo              6   0 /var/run/utmp
    610    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
    610    dbus-daemon        21   0 /usr/share/dbus-1/system-services
    610    dbus-daemon        -1   2 /lib/dbus-1/system-services
    610    dbus-daemon        21   0 /var/lib/snapd/dbus-1/system-services/

---
6. Какой системный вызов использует uname -a? Приведите цитату из man

Системный вызов uname
> Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}

---
7. Чем отличается последовательность команд через ; и через && в bash? Есть ли смысл использовать в bash &&, если применить `set -e`?

Команды, разделённые `;`, выполняются последовательно - shell ждёт окончания выполнения каждой команды и возвращает вывод последней команды, вне зависимости от выполнения предыдущих

`&&` - оператор AND. Команды, раздёленные `&&`, выполняются только если предыдущая команда выполнилась со статусом 0 (успех)

Судя по мануалу bash, если в списке команд используется оператор `&&`, shell не будет завершать выполнение скрипта при наличии `set -e`:

> The shell does not exit if the command that fails is part of the command list immediately following a while or until keyword ... part of any command executed in a && or || list except the command following the final && or  || ...

Следовательно, отвечая на вопрос - да, смысл есть, если необходимо не прерывать выполнение скрипта при обнаружении ошибки в процессе выполенния команд.

---
8. Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?

* `set -e` - немедленно прерывает выполнение команд(ы), если в процессе получен любой статус, отличный от нуля (т.е. не успех)
* `set -u` - обрабатывает неустановленные или неопределенные переменные (за исключением специальных параметров, таких как подстановочные знаки (*) или «@») как ошибки во время раскрытия параметра. В неинтерактивном режиме shell выходит с не-нулевым статусом, в противном случае - выводит ошибку.
* `set -x` - печатает аргументы команды во время выполнения
* `set -o pipefail` - если установлено, возвращаемое значение конвейера - это значение последней (самой правой) команды для выхода с ненулевым статусом или ноль, если все команды в конвейере завершаются успешно. По умолчанию эта опция отключена.

Полезно использовать для увеличения детализации хода выполнения сценария, а также безопасного завершения работы сценария при наличии ошибок

---
9. Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

```bash
$ ps -eo s --cumulative --sort=stat | uniq -c
```
    1 S
    46 I
    1 R
    59 S

Самый часто встречающийся статус - S (interruptible sleep), прерываемый сон. Ожидают дальнейшей команды/сигналов